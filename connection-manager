#!/usr/bin/perl
##############################################################################
#
#   File Name    - connection-manager
#
#   Description  - Perl system tray GUI utility for connecting to remote
#                  hosts using either xfreerdp or ssh.
#
#   Author       - A.E.Cooper.
#
#   Legal Stuff  - Copyright (c) 2024 Anthony Edward Cooper
#                  <aecooper@cpan.org>.
#
#                  This program is free software; you can redistribute it
#                  and/or modify it under the terms of the GNU General Public
#                  License as published by the Free Software Foundation;
#                  either version 3 of the License, or (at your option) any
#                  later version.
#
#                  This program is distributed in the hope that it will be
#                  useful, but WITHOUT ANY WARRANTY; without even the implied
#                  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#                  PURPOSE. See the GNU General Public License for more
#                  details.
#
#                  You should have received a copy of the GNU General Public
#                  License along with this software; if not, write to the Free
#                  Software Foundation, Inc., 59 Temple Place - Suite 330,
#                  Boston, MA 02111-1307 USA.
#
##############################################################################
#
##############################################################################
#
#   Global Data For This Module
#
##############################################################################



# ***** DIRECTIVES *****

use 5.036;
use strict;
use warnings;

# ***** REQUIRED PACKAGES *****

# Standard Perl and CPAN modules.

use Config::Verifier;
use Data::Dumper;
use English;
use Expect;
use File::Basename;
use File::Spec;
use Glib qw(FALSE TRUE);
use Gtk3 -init;
use IO::File;
use IO::Socket::INET;
use Locale::TextDomain ('connection-manager');
use POSIX qw(:errno_h :sys_wait_h _exit);
use YAML::XS;

# ***** GLOBAL DATA DECLARATIONS *****

# Constant for the name of the icon used by the application.

use constant ICON_NAME => 'preferences-system-login';

# Constants for the name of the user's settings files.

use constant USER_RDP_HISTORY_FILE => 'connection-manager-rdp-history.dat';
use constant USER_SETTINGS_FILE    => 'connection-manager.yml';

# The general settings for the application.

my $settings = {debug => 0};

# REs for matching file name, SSH command and window title tokens.

my $desktop_height_token_re = qr/\{desktop-height\}/;
my $desktop_usable_height_token_re = qr/\{desktop-usable-height\}/;
my $desktop_usable_width_token_re = qr/\{desktop-usable-width\}/;
my $desktop_width_token_re = qr/\{desktop-width\}/;
my $file_name_token_re = qr/^\{file-name\}$/;
my $ssh_cmd_args_token_re = qr/^\{ssh-command-args\}$/;
my $ssh_cmd_token_re = qr/\{ssh-command\}/;
my $ssh_cmd_tokens_re = qr/\{(?:ssh-command|ssh-command-args)\}/;
my $window_title_token_re = qr/\{title\}/;

my @host =
    ('l:choice_value',
     'R:hostname',
     'R:ipv4_addr',
     'R:ipv6_addr');
my %rdp_settings =
    ('s:port'               => 'i:1,65535',
     's:user'               => 'R:user_name',
     's:domain_name'        => 'R:hostname',
     's:window_mode'        => 'r:^(?:fullscreen'
                                   . '|maximised-no-boarders)'
                                   . '|(?:\d+x\d+)$',
     's:colour_depth'       => 'r:^(?:8|16|24|32)$',
     's:compression_level'  => 'r:^(?:0|1|2)$',
     's:disk_shares'        => 'r:^[^ ,;]+,[^,;]+(?:;[^ ,;]+,'
                                   . '[^,;]+)*$',
     's:network'            => 'r:^(?:|auto'
                                   . '|broadband'
                                   . '|broadband-high'
                                   . '|broadband-low'
                                   . '|lan'
                                   . '|modem'
                                   . '|wan)$',
     's:tls_security_level' => 'f:0,5.9',
     's:admin'              => 'R:boolean',
     's:bitmap_cache'       => 'R:boolean',
     's:compositor'         => 'R:boolean',
     's:compress'           => 'R:boolean',
     's:home_drive'         => 'R:boolean',
     's:ignore_certs'       => 'R:boolean',
     's:keyboard_grab'      => 'R:boolean',
     's:menu_animations'    => 'R:boolean',
     's:microphone'         => 'R:boolean',
     's:share_clipboard'    => 'R:boolean',
     's:smooth_fonts'       => 'R:boolean',
     's:sound'              => 'R:boolean',
     's:themes'             => 'R:boolean',
     's:toolbar'            => 'R:boolean',
     's:window_drag'        => 'R:boolean',
     's:wallpaper'          => 'R:boolean',
     's:custom_arguments'   => 'R:anything');
my %vnc_settings =
    ('s:port'    => 'i:1,65535',
     's:profile' => 'r:^[^/]+$');
my %ssh_settings =
    ('s:port'             => 'i:1,65535',
     's:user'             => 'R:user_name',
     's:keep_alive'       => 'R:boolean',
     's:x11_tunnel'       => 'R:boolean',
     's:custom_arguments' => ['R:anything']);
my %settings_syntax_tree =
    ('m:config_version' => 'f:0',
     's:settings'       =>
         {'s:terminal'              => ['R:anything'],
          's:editor'                => ['R:anything'],
          's:rdp_defaults'          => \%rdp_settings,
          's:ssh_defaults'          => \%ssh_settings,
          's:vnc_defaults'          => \%vnc_settings,
          's:tigervnc_profile_path' => 'R:unix_path',
          's:history_size'          => ['i:1,50'],
          's:debug'                 => 'R:boolean'},
     'm:menu'           =>
         [{'m:separator' =>
               {'s:text'      => 'R:printable',
                's:draw_line' => 'R:boolean'}},
          {'m:rdp'       =>
               {'m:name'      => 'R:printable',
                'm:host'      => \@host,
                %rdp_settings}},
          {'m:ssh'       =>
               {'m:name'      => 'R:printable',
                'm:host'      => \@host,
                %ssh_settings}},
          {'m:vnc'       =>
               {'m:name'      => 'R:printable',
                'm:host'      => \@host,
                %vnc_settings}},
          {'m:menu'      =>
               {'m:name'      => 'R:printable',
                'm:items'     => undef}}]);

my $setting_header = <<'EOF';
# Notes:
# - Defaults are shown with *.
# - One can use the following tokens when specifying a terminal application:
#   - `{ssh-command}'      : Expands to a single string containing the complete
#                            ssh command.
#   - `{ssh-command-args}' : Expands to a list of strings, one for each argument
#                            of the ssh command. This token only works as a
#                            dedicated entry in a list of strings (i.e.
#                            "freddy{ssh-command-args}" won't be recognised).
#   - `{title}'            : Expands to contain one string, containing a
#                            meaningful title for a terminal window.
#   One of the ssh tokens must be supplied for the terminal entry to be valid.
# - One can use the following tokens when specifying a text editor application:
#   - `{file-name}' : Expands to a single string containing the name of the file
#                     that is to be edited.
#   The file name token must be supplied for the editor entry to be valid.
# - In the examples below some default values are calculated at runtime. For
#   example, default desktop sizes and user names. Some meanings:
#   - `<Not Specified>' : No option is specified to the supporting application
#                         and so its own default setting applies.
#   - `option1|option2' : Details the options that can be used for that setting.
# - The custom_arguments field is supported for RDP and SSH sessions (VNC
#   sessions use TigerVNC profiles so any custom settings can go into those
#   profiles). This gives the user the opportunity to add additional switches
#   that aren't natively supported by this application, such as SSH tunnels or
#   SSH key identities. If you so wish you can make use of the following tokens:
#   - `{desktop-width}'         : The width of the desktop in pixels.
#   - `{desktop-height}'        : The height of the desktop in pixels.
#   - `{desktop-usable-width}'  : The usable width of the desktop in pixels,
#                                 taking into account panels (work area).
#   - `{desktop-usable-height}' : The usable height of the desktop in pixels,
#                                 taking into account panels (work area).
#
# config_version: 1.0
# settings:
#   terminal: ["konsole",                         *
#              "-p",
#              "RemoteTabTitleFormat={title}",
#              "-e",
#              "{ssh-command-args}"]
#   editor: ["vim", "{file-name}"                 *
#   rdp_defaults:
#   ssh_defaults:
#   vnc_defaults:
#     The above `*_defaults' records can be used to override the built in
#     default values for assorted fields within those connection types. With the
#     exception of the `name' and `host' fields all of the others are valid.
#     Please look at the RDP, SSH and VNC menu entries below to find out the
#     field names and their built in default values.
#   tigervnc_profile_path: ~/.vnc                 *
#   history_size: 20                              *
#   debug: false                                  *
#
# menu:
#   - separator:
#       text: null                                *
#       draw_line: false                          * # True if no `text'.
#   - rdp:
#       name:
#       host:
#       port: 3389                                *
#       user: <Your User Name>                    *
#       domain_name: <Not Specified>              *
#       window_mode: maximised-no-boarders        *
#                    fullscreen|maximised-no-boarders|<Width>x<Height>
#       colour_depth: 32                          *
#       compression_level: <Not Specified>        *
#       disk_shares: <Not Specified>              *
#       network: <Not Specified>                  *
#                auto|broadband|broadband-high|broadband-low|lan|modem|wan
#       tls_security_level: <Not Specified>       *
#       admin: false                              *
#       bitmap_cache: false                       *
#       compositor: true                          *
#       compress: true                            *
#       home_drive: false                         *
#       ignore_certs: false                       *
#       keyboard_grab: true                       *
#       menu_animations: true                     *
#       microphone: false                         *
#       share_clipboard: true                     *
#       smooth_fonts: true                        *
#       sound: false                              *
#       themes: true                              *
#       toolbar: false                            *
#       wallpaper: true                           *
#       window_drag: true                         *
#       custom_arguments: []                      *
#   - vnc:
#       name: Linux Desktop
#       host: linux-dev.work.org
#       port: 1                                   * # VNC port not socket.
#       profile: default                          * # Name of TigerVNC profile.
#   - ssh:
#       name: Linux Desktop
#       host: linux-dev.work.org
#       port: 22                                  *
#       user: fblogs                              *
#       keep_alive: false                         *
#       x11_tunnel: false                         *
#       custom_arguments: []                      *
#   - menu:
#       name: Lab Virtual Machines
#       items:
#         - ssh:
#             name: Play Pen
#             host: play.lab.home.org
#             user: system
#         - .
#         - .
#         - .
config_version: 1.0
menu:
  - separator:
      text: Empty - Please edit your prefereses
EOF

# ***** FUNCTIONAL PROTOTYPES *****

# Private routines.

state sub create_connections_menu;
state sub create_options_menu;
state sub create_password_dialog;
state sub create_rdp_connection_dialog;
state sub find_rdp_session_entry;
state sub handle_rdp_menu_entry;
state sub iterator($hash_ref)
{
    my @keys = keys(%$hash_ref);
    return sub
           {
               my $key = shift(@keys);
               return ($key, $hash_ref->{$key}) if (defined($key));
               return;
           };
}
state sub load_rdp_history;
state sub load_settings;
state sub logger($format, @args)
{
    STDERR->printf("%s\n", sprintf($format, @args));
    return;
}
state sub patch_up_syntax_table;
state sub ping_host;
state sub process_custom_argument_tokens;
state sub problem_dialog;
state sub rdp_menu_entry_cb;
state sub run_command;
state sub settings_file_full_path;
state sub settings_file_has_changed;
state sub ssh_menu_entry_cb;
state sub title_event_cb;
state sub update_rdp_history;
state sub vnc_menu_entry_cb;
state sub vnc_path;
state sub yaml_data_to_objects;

# ***** PACKAGE INFORMATION *****

# We are just a program.

our $VERSION = '1.0';
#
##############################################################################
#
#   Routine      - Main Body Of Code
#
#   Description  - This is the main body of code for the mtn-browse script.
#
#   Data         - @_           : The command line arguments.
#                  Return Value : Unix exit code.
#
##############################################################################



{

    my $sessions;
    my $exit_code = 0;

    # Automatically reap zombie child processes.

    $SIG{CHLD} = 'IGNORE';

    # Patch up the syntax tree to cope with recursive menu definitions and
    # duplicates.

    patch_up_syntax_table();

    # Prime the update checker.

    settings_file_has_changed();

    # Load the user's settings to get the list of sessions.

    if (not load_settings(\$sessions, \$settings))
    {
        if ($!)
        {
            problem_dialog('error',
                           __x('Your preferences could not be loaded, the '
                                   . "reason given was:\n"
                                   . '<b><i>{error_message}</i></b>',
                               error_message => Glib::Markup::escape_text($!)));
        }
        exit(1);
    }

    # Check command line arguments for RDP helper invocation.

    if (@ARGV == 2 and $ARGV[0] eq '--rdp' and $ARGV[1] =~ m/^-?\d+$/)
    {

        # Find the RDP entry via its unique id and then run as an RDP helper
        # subprocess.

        my $rdp_session = find_rdp_session_entry($sessions, $ARGV[1]);
        if (defined($rdp_session))
        {
            Glib::Idle->add
                (sub {
                     $exit_code = handle_rdp_menu_entry($rdp_session);
                     Gtk3->main_quit();
                     return FALSE;
                 });

            # Hand control over to Gtk3.

            Gtk3->main();
        }
        else
        {
            problem_dialog
                ('error', __('Internal error: Invalid --rdp argument.'));
            $exit_code = 1;
        }

    }
    else
    {

        my ($connections_menu,
            $options_menu,
            $tray_icon);

        # Run as a system tray utility.

        # Create the system tray icon widget.

        $tray_icon =
            Gtk3::StatusIcon->new_from_icon_name('preferences-system-login');
        $tray_icon->set_title(__('Connection Manager'));

        # Create the menus.

        $connections_menu = create_connections_menu($sessions);
        $options_menu = create_options_menu($sessions);

        # Deal with button release events.

        $tray_icon->signal_connect
            ('button-release-event',
             sub {
                 my ($widget, $event) = @_;
                 if (settings_file_has_changed()
                     and load_settings(\$sessions, \$settings))
                 {
                     $connections_menu->destroy();
                     $connections_menu = create_connections_menu($sessions);
                 }
                 if ($event->button() == 1)
                 {
                     $connections_menu->popup(undef,
                                              undef,
                                              undef,
                                              undef,
                                              $event->button(),
                                              $event->time());
                     return TRUE;
                 }
                 elsif ($event->button() == 3)
                 {
                     $options_menu->popup(undef,
                                          undef,
                                          undef,
                                          undef,
                                          $event->button(),
                                          $event->time());
                     return TRUE;
                 }
                 return FALSE;
             });

        $connections_menu->show_all();
        $options_menu->show_all();

        # Hand control over to Gtk3.

        Gtk3->main();

    }

    exit($exit_code);

}
#
##############################################################################
#
#   Routine      - rdp_menu_entry_cb
#
#   Description  - Callback routine called when the user selects an RDP
#                  connection menu entry.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $id      : The id for the RDP session entry or -1 for the
#                             generic blank RDP entry.
#
##############################################################################



sub rdp_menu_entry_cb($widget, $id)
{

    # We need to fork() and exec() this program as xfreerdp doesn't return and
    # we need to run Expect on it to securely pass in the password when
    # prompted. The exec() call is necessary to create new X Windows client
    # connections rather than use the parent's.

    if (fork() == 0)
    {
        exec($PROGRAM_NAME, '--rdp', $id);
    }

}
#
##############################################################################
#
#   Routine      - vnc_menu_entry_cb
#
#   Description  - Callback routine called when the user selects a VNC
#                  connection menu entry.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $details : A record containing the VNC connection details.
#
##############################################################################



sub vnc_menu_entry_cb($widget, $details)
{

    my (@args,
        $fh,
        $line,
        $profile_file);

    # Read in the specified profile file.

    $profile_file = File::Spec->catfile(vnc_path,
                                        $details->{profile} . '.tigervnc');
    if (not defined($fh = IO::File->new($profile_file, 'r')))
    {
        problem_dialog('warning',
                       __x("TigerVNC profile file\n`{profile}'\n"
                               .'cannot be read.',
                           profile => $profile_file));
        return;
    }

    # Check the remote host.

    return unless ping_host($details->{host},
                            defined($details->{port})
                                ? ($details->{port} + 5900) : 5901,
                            2);

    # Build up the command by using the options in the profile file.

    @args = ('xtigervncviewer');
    while ($line = $fh->getline())
    {
        chomp($line);

        # Skip uninteresting lines.

        next if ($line !~ m/^[^=]+=[^=]*$/ or $line =~ m/^ServerName=/);

        # Simply add option to the command line.

        push(@args, '--' . $line);
    }
    $fh->close();

    # Append the server and port details.

    push(@args, $details->{host} . ':' . $details->{port});

    # Run the command.

    run_command(@args);

    return;

}
#
##############################################################################
#
#   Routine      - ssh_menu_entry_cb
#
#   Description  - Callback routine called when the user selects an SSH
#                  connection menu entry.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $details : A record containing the SSH connection details.
#
##############################################################################



sub ssh_menu_entry_cb($widget, $details)
{

    my (@args,
        @ssh_cmd);

    # Check the remote host.

    return unless ping_host($details->{host},
                            defined($details->{port}) ? $details->{port} : 22,
                            2);

    # Build up the SSH command.

    push(@ssh_cmd, 'ssh');
    push(@ssh_cmd, '-Y') if ($details->{x11_tunnel});
    push(@ssh_cmd, '-p', $details->{port}) if (defined($details->{port}));
    push(@ssh_cmd, '-o', 'ServerAliveInterval=60')
        if (defined($details->{keep_alive}));
    push(@ssh_cmd,
         process_custom_argument_tokens($details->{custom_arguments}));
    push(@ssh_cmd, sprintf('%s@%s', $details->{user}, $details->{host}));

    # Sort out the terminal command and its arguments.

    foreach my $arg (@{$settings->{terminal}})
    {
        if ($arg =~ m/$ssh_cmd_token_re/)
        {
            my $ssh_cmd = join(' ', @ssh_cmd);
            push(@args, $arg =~ s/$ssh_cmd_token_re/$ssh_cmd/gr);
        }
        elsif ($arg =~ m/$ssh_cmd_args_token_re/)
        {
            push(@args, @ssh_cmd);
        }
        elsif ($arg =~ m/$window_title_token_re/)
        {
            my $title = sprintf('%s@%s%s',
                                $details->{user},
                                $details->{host},
                                $details->{x11_tunnel} ?  ' (X11)' : '');
            push(@args, $arg =~ s/$window_title_token_re/$title/gr);
        }
        else
        {
            push(@args, $arg);
        }
    }

    # Run the command, konsole backgrounds itself.

    run_command(@args);

    return;

}
#
##############################################################################
#
#   Routine      - handle_rdp_menu_entry
#
#   Description  - Handle running xfreerdp in a subprocess as it doesn't
#                  daemonise and we need to monitor its input and output.
#
#   Data         - $details     : A record containing the RDP connection
#                                 details.
#                  Return Value : The exit code for the process.
#
##############################################################################



sub handle_rdp_menu_entry($details)
{

    my ($err,
        $warning_msg);
    my $output = '';

    # If we don't have any connection details then ask for them.

    if (not defined($details->{host}) or not defined($details->{user}))
    {
        my $input;
        my $dialog = create_rdp_connection_dialog(\$input);
        $dialog->run();
        $dialog->destroy();
        while (Gtk3::events_pending())
        {
            Gtk3::main_iteration();
        }
        if (defined($input))
        {
            if ($input =~ m/^(?:([^\\]+)\\)?([^@]+)@([^:]+)(?::(\d+))?$/)
            {
                my ($domain, $user, $host, $port) = ($1, $2, $3, $4);
                $details->{domain} = $domain;
                $details->{user} = $user;
                $details->{host} = $host;
                $details->{port} = $port;
            }
            else
            {
                $warning_msg =
                    __('The information entered is not an RDP endpoint.');
            }
        }
    }

    # Only proceed if we are good to go.

    if (not defined($warning_msg)
        and defined($details->{host}) and defined($details->{user}))
    {

        # Check the remote host.

        return 1 unless ping_host($details->{host},
                                  defined($details->{port})
                                      ? $details->{port} : 3389,
                                  2);

        # Sort out the command and its arguments.

        my @args;
        push(@args, 'xfreerdp');
        push(@args, '/v:' . $details->{host});
        push(@args, '/port:' . $details->{port})
            if (defined($details->{port}));
        push(@args, '/u:' . $details->{user});
        push(@args, '/d:' . $details->{domain})
            if (defined($details->{domain}));
        if ($details->{window_mode} eq 'fullscreen')
        {
            push(@args, '/f');
        }
        elsif ($details->{window_mode} eq 'maximised-no-boarders')
        {
            push(@args, '/workarea', '-decorations');
        }
        elsif ($details->{window_mode} =~ m/^\d+x\d+$/)
        {
            push(@args, '/size:' . $details->{window_mode});
        }
        push(@args, '/bpp:' . $details->{colour_depth});
        push(@args, '/compression-level:' . $details->{compression_level})
            if (defined($details->{compression_level}));
        if (defined($details->{disk_shares})
            and $details->{disk_shares} =~
                m/^[^ ,;]+,[^,;]+(?:;[^ ,;]+,[^,;]+)*$/)
        {
            foreach my $entry (split(/;/, $details->{disk_shares}))
            {
                push(@args, '/drive:' . $entry);
            }
        }
        push(@args, '/network:' . $details->{network})
            if (defined($details->{network}));
        push(@args, '/tls-seclevel:' . $details->{tls_security_level})
            if ($details->{tls_security_level} ne '1');
        my %transform = ('bitmap_cache'    => 'bitmap-cache',
                         'compositor'      => 'aero',
                         'compress'        => 'compression',
                         'home_drive'      => 'home-drive',
                         'keyboard_grab'   => 'grab-keyboard',
                         'menu_animations' => 'menu-anims',
                         'share_clipboard' => 'clipboard',
                         'smooth_fonts'    => 'fonts',
                         'themes'          => 'themes',
                         'wallpaper'       => 'wallpaper',
                         'window_drag'     => 'window-drag');
        my $iter = iterator(\%transform);
        while (my ($mine, $rdps) = $iter->())
        {
            push(@args, ($details->{$mine} ? '+' : '-') . $rdps);
        }
        %transform = ('admin'        => '/admin',
                      'ignore_certs' => '/cert:ignore',
                      'microphone'   => '/microphone',
                      'sound'        => '/sound',
                      'toolbar'      => '/floatbar:sticky:on');
        $iter = iterator(\%transform);
        while (my ($mine, $rdps) = $iter->())
        {
            push(@args, $rdps) if ($details->{$mine});
        }
        push(@args,
             process_custom_argument_tokens($details->{custom_arguments}));
        if ($settings->{debug})
        {
            logger("Command arguments dump:\n%s%s",
                   Data::Dumper->Dump([\@args], ['*args']),
                   join(' ', @args));
        }

        # Xfreerdp is a great tool but diagnostically it's hard to tell when
        # it has worked. So we monitor its output for the usual suspects but
        # also as a catch all, if it exits too quickly then clearly
        # something that hasn't been considered has happened and we need to
        # display something to the user.

        my $start_time = time();

        # Now run it via Expect so we can feed in the password and watch for
        # errors.

        $err = 1;
        my ($hard_close,
            $user_logged_out);
        my $cmd_handle = Expect->new();
        $cmd_handle->log_group(1);
        $cmd_handle->log_stdout(($settings->{debug}) ? 1 : 0);
        $cmd_handle->log_file(sub { $output .= $_[0]; });
        $cmd_handle->spawn(@args) or die("Cannot spawn command: $!");
        $cmd_handle->
            expect(undef,
                   [qr/Password:/ =>
                        sub
                        {
                            my $password;
                            my $dialog = create_password_dialog($details,
                                                                \$password);
                            $dialog->run();
                            $dialog->destroy();
                            while (Gtk3::events_pending())
                            {
                                Gtk3::main_iteration();
                            }

                            # Log in with the password or abort by quietly
                            # closing down.

                            if (defined($password))
                            {
                                $cmd_handle->send($password . "\n");
                                $err = 0;
                                return exp_continue;
                            }
                            else
                            {
                                $err = $start_time = 0;
                                $hard_close = 1;
                                return;
                            }
                        }],
                   [qr/Do you trust the above certificate\? \(Y\/T\/N\)/ =>
                        sub
                        {
                            my $dialog;
                            $output =~ s/^.+\] - //gm;
                            $dialog = Gtk3::MessageDialog->new(undef,
                                                               ['modal'],
                                                               'warning',
                                                               'ok_cancel',
                                                               $output);
                            $dialog->set_title(__('Change In Certificate'));
                            $dialog->set_icon_name(ICON_NAME);
                            $dialog->set_position('center-always');
                            my $response = $dialog->run();
                            $dialog->destroy();
                            $output = '';
                            if ($response eq 'ok')
                            {
                                $cmd_handle->send("Y\n");
                                return exp_continue;
                            }
                            else
                            {
                                $cmd_handle->send("N\n");

                                # Make sure we close down quietly.

                                $err = $start_time = 0;
                                $hard_close = 1;
                                return;
                            }
                        }],
                   [qr/REMOTE HOST IDENTIFICATION HAS CHANGED/ =>
                        sub
                        {
                            $warning_msg =
                                __('The key for the remote host has changed.'
                                   .     "\n\n"
                                   . 'Edit ~/.config/freerdp/known_hosts if '
                                       . "this is expected,\n"
                                   . 'otherwise something nasty has happened!');

                            # This may not close as xfreerdp in some versions
                            # then goes on to prompt for whether the new
                            # certificate should be accepted. We don't want this
                            # so force it to stop.

                            $hard_close = 1;
                            return;
                        }],
                   [qr/AUTHENTICATION_FAILED|LOGON_FAILURE/ =>
                        sub
                        {
                            $warning_msg = __('Incorrect password.');
                            $err = 1;
                            return;
                        }],
                   [qr/ERRCONNECT_DNS_NAME_NOT_FOUND/ =>
                        sub
                        {
                            $warning_msg =
                                __('The remote host is unknown.');
                            return;
                        }],
                   [qr/ERRCONNECT_CONNECT_TRANSPORT_FAILED/ =>
                        sub
                        {
                            $warning_msg = __('The remote host is down or '
                                              . 'unreachable.');
                            return;
                        }],
                   [qr/ERRINFO_LOGOFF_BY_USER/ =>
                        sub
                        {
                            $err = 0;
                            $user_logged_out = 1;
                            return;
                        }]);
        if ($hard_close)
        {
            $cmd_handle->hard_close();
        }
        else
        {
            $cmd_handle->soft_close();
        }

        # If the subprocess exited too quickly and the user didn't log out then
        # make sure $err is set.

        $err = 1 if (not $user_logged_out and (time() - $start_time) < 5);

    }

    if ($err)
    {
        my $msg;
        if (defined($warning_msg))
        {
            $msg = Glib::Markup::escape_text($warning_msg);
        }
        else
        {
            chomp($output);
            $msg = __x("Oops, something went wrong:\n<b><i>{output}</i></b>",
                       output => Glib::Markup::escape_text($output));
        }
        problem_dialog('warning', $msg);
        return 1;
    }

    return 0;

}
#
##############################################################################
#
#   Routine      - create_connections_menu
#
#   Description  - Creates and populates a menu with the specified session
#                  details.
#
#   Data         - $sessions    : A reference to the list of sessions.
#                  Return Value : The menu widget.
#
##############################################################################



sub create_connections_menu($sessions)
{

    my ($label,
        $menu_item);
    my $menu = Gtk3::Menu->new();
    foreach my $entry (@$sessions)
    {
        if (ref($entry) eq 'separator')
        {

            # Override the draw_line setting to true if there's no title. We
            # have been asked for a separator after all.

            if ($entry->{draw_line} or not defined($entry->{text}))
            {
                $menu_item = Gtk3::SeparatorMenuItem->new();
                $menu_item->show();
                $menu->append($menu_item);
            }
            if (defined($entry->{text}))
            {
                $menu_item = Gtk3::MenuItem->new();
                $label = Gtk3::Label->new();
                $label->set_markup('<b>' . $entry->{text} . '</b>');
                $label->show();
                $menu_item->add($label);
                $menu->append($menu_item);
                $menu_item->signal_connect('event', \&title_event_cb);
                $menu_item->show();
            }

        }
        elsif (ref($entry) eq 'rdp')
        {
            $menu_item = Gtk3::MenuItem->new(__x('{name} - RDP ({user})',
                                                 name => $entry->{name},
                                                 user => $entry->{user}));
            $menu->append($menu_item);
            $menu_item->signal_connect('activate',
                                       \&rdp_menu_entry_cb,
                                       $entry->{id});
            $menu_item->show();
        }
        elsif (ref($entry) eq 'vnc')
        {
            $menu_item = Gtk3::MenuItem->new(__x('{name} - VNC',
                                                 name => $entry->{name}));
            $menu->append($menu_item);
            $menu_item->signal_connect('activate',
                                       \&vnc_menu_entry_cb,
                                       $entry);
            $menu_item->show();
        }
        elsif (ref($entry) eq 'ssh')
        {
            $menu_item = Gtk3::MenuItem->new(__x('{name} - SSH ({user})',
                                                 name => $entry->{name},
                                                 user => $entry->{user}));
            $menu->append($menu_item);
            $menu_item->signal_connect('activate',
                                       \&ssh_menu_entry_cb,
                                       $entry);
            $menu_item->show();
        }
        elsif (ref($entry) eq 'menu')
        {
            $menu_item = Gtk3::MenuItem->new(__x($entry->{name}));
            $menu_item->set_submenu(create_connections_menu($entry->{items}));
            $menu->append($menu_item);
            $menu_item->show();
        }
    }

    return $menu;

}
#
##############################################################################
#
#   Routine      - create_options_menu
#
#   Description  - Creates and populates a menu with the main options.
#
#   Data         - $sessions    : A refernce to the list of sessions.
#                  Return Value : The menu wdiget.
#
##############################################################################



sub create_options_menu($sessions)
{

    my $menu = Gtk3::Menu->new();

    my $menu_item = Gtk3::MenuItem->new();
    my $label = Gtk3::Label->new();
    $label->set_markup(__('<b>Options</b>'));
    $label->show();
    $menu_item->add($label);
    $menu->append($menu_item);
    $menu_item->signal_connect('event', \&title_event_cb);
    $menu_item->show();

    $menu_item = Gtk3::MenuItem->new(__('_RDP'));
    $menu->append($menu_item);
    $menu_item->signal_connect('activate', \&rdp_menu_entry_cb, -1);
    $menu_item->show();

    $menu_item = Gtk3::MenuItem->new(__('_TigerVNC'));
    $menu->append($menu_item);
    $menu_item->signal_connect
        ('activate',
         sub {
             run_command('xtigervncviewer');
         });
    $menu_item->show();

    $menu_item = Gtk3::MenuItem->new(__('_Edit Preferences'));
    $menu->append($menu_item);
    $menu_item->signal_connect
        ('activate',
         sub {
             my @args;
             my $file_name = settings_file_full_path(USER_SETTINGS_FILE);
             for my $arg (@{$settings->{editor}})
             {
                 if ($arg =~ m/$file_name_token_re/)
                 {
                     push(@args, $arg =~ s/$file_name_token_re/$file_name/gr);
                 }
                 else
                 {
                     push(@args, $arg);
                 }
             }
             run_command(@args);
         });
    $menu_item->show();

    $menu_item = Gtk3::MenuItem->new(__('_Quit'));
    $menu->append($menu_item);
    $menu_item->signal_connect
        ('activate',
         sub {
             Gtk3->main_quit();
         });
    $menu_item->show();

    return $menu;

}
#
##############################################################################
#
#   Routine      - create_rdp_connection_dialog
#
#   Description  - Create a dialog that asks for a user name and host and
#                  return it to the caller.
#
#   Data         - $input       : A reference to a variable that is to contain
#                                 the user's input.
#                  Return Value : The created Gtk3::Dialog widget.
#
##############################################################################



sub create_rdp_connection_dialog($input)
{

    my ($combobox,
        $dialog,
        $entry,
        $label,
        $table,
        $vbox);

    $dialog = Gtk3::Dialog->new(__('RDP Connection Details'),
                                undef,
                                ['modal'],
                                'gtk-cancel' => 'cancel',
                                'gtk-ok' => 'ok');
    $dialog->set_icon_name(ICON_NAME);
    $dialog->set_default_response('ok');
    $dialog->set_response_sensitive ('ok', FALSE);
    $dialog->set_position('center-always');
    $dialog->set_resizable(FALSE);
    $vbox = $dialog->get_content_area();
    $vbox->set_border_width(5);
    $table = Gtk3::Table->new(1, 2, FALSE);
    $label = Gtk3::Label->new(__('Connection details '
                                 . '([domain\]user@host[:port]):'));
    $label->set_alignment(1, 0.5);
    $table->attach_defaults($label, 0, 1, 0, 1);
    $combobox = Gtk3::ComboBoxText->new_with_entry();
    foreach my $entry (load_rdp_history())
    {
        $combobox->append_text($entry);
    }
    $entry = $combobox->get_child();
    $entry->set_text('');
    $entry->set_width_chars(40);
    $entry->set_activates_default(TRUE);
    $entry->signal_connect
        ('changed',
         sub {
             my $text = $entry->get_text;
             if ($entry->get_text()
                 =~ m/^(?:[-_.$!a-zA-Z0-9]+\\)?  # Optional domain name.
                      [-_.$!a-zA-Z0-9]+@         # Mandatory user name.
                      [-_.a-zA-Z0-9]+            # Mandatory host name.
                      (?::\d+)?$/x)              # Optional port number.
             {
                 $dialog->set_response_sensitive('ok', TRUE);
             }
             else
             {
                 $dialog->set_response_sensitive('ok', FALSE);
             }
         });
    $dialog->signal_connect
        ('response',
         sub {
             my ($widget, $button) = @_;
             if ($button eq 'ok')
             {
                 $$input = $entry->get_text();
                 update_rdp_history($$input);
             }
         });
    $table->attach_defaults($combobox, 1, 2, 0, 1);
    $vbox->pack_start($table, 0, 0, 4);
    $vbox->show_all();

    return $dialog;

}
#
##############################################################################
#
#   Routine      - create_password_dialog
#
#   Description  - Create a password dialog and return it to the caller.
#
#   Data         - $details     : A record containing the RDP connection
#                                 details.
#                  $password    : A reference to a variable that is to contain
#                                 the password.
#                  Return Value : The created Gtk3::Dialog widget.
#
##############################################################################



sub create_password_dialog($details, $password)
{

    my ($dialog,
        $entry,
        $label,
        $table,
        $vbox);

    $dialog = Gtk3::Dialog->new(__('RDP Password'),
                                undef,
                                ['modal'],
                                'gtk-cancel' => 'cancel',
                                'gtk-ok' => 'ok');
    $dialog->set_icon_name(ICON_NAME);
    $dialog->set_default_response('ok');
    $dialog->set_response_sensitive ('ok', FALSE);
    $dialog->set_position('center-always');
    $dialog->set_resizable(FALSE);
    $vbox = $dialog->get_content_area();
    $vbox->set_border_width(5);
    $table = Gtk3::Table->new(1, 2, FALSE);
    $label = Gtk3::Label->new(__x('Password for {user}@{host}:',
                                  user => $details->{user},
                                  host => $details->{host}));
    $label->set_alignment(1, 0.5);
    $table->attach_defaults($label, 0, 1, 0, 1);
    $entry = Gtk3::Entry->new();
    $entry->set_visibility(FALSE);
    $entry->set_text('');
    $entry->set_activates_default(TRUE);
    $entry->signal_connect
        ('changed',
         sub {
             my $text = $entry->get_text;
             if ($entry->get_text() ne '')
             {
                 $dialog->set_response_sensitive('ok', TRUE);
             }
             else
             {
                 $dialog->set_response_sensitive('ok', FALSE);
             }
         });
    $dialog->signal_connect
        ('response',
         sub {
             my ($widget, $button) = @_;
             if ($button eq 'ok')
             {
                 $$password = $entry->get_text();
             }
         });
    $table->attach_defaults($entry, 1, 2, 0, 1);
    $vbox->pack_start($table, 0, 0, 4);
    $vbox->show_all();

    return $dialog;

}
#
##############################################################################
#
#   Routine      - title_event_cb
#
#   Description  - Event handler for title entries that is designed to
#                  suppress menu selection events.
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : The Gtk3::Gdk::Event object representing the
#                                 current event.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise FALSE if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub title_event_cb($widget, $event)
{

    my $type = $event->type();

    if ($type eq 'motion-notify'
        or $type eq 'enter-notify'
        or $type eq 'leave-notify'
        or $type eq 'button-press'
        or $type eq 'button-release')
    {
        return TRUE;
    }

    return FALSE;

}
#
##############################################################################
#
#   Routine      - run_command
#
#   Description  - Simply runs the specified command in a subprocess,
#                  returning straight away.
#
#   Data         - @cmd : The command that is to be run. This can be in the
#                         form of either a single string containing the
#                         command with space separated arguments (optionally
#                         using special shell characters if so desired) or
#                         each word separated out into a list of separate
#                         strings.
#
##############################################################################



sub run_command(@cmd)
{

    my $child;

    if ($settings->{debug})
    {
        logger("Command arguments dump:\n%s%s",
               Data::Dumper->Dump([\@cmd], ['*args']),
               join(' ', @cmd));
    }

    # Start trapping SIGCHLD so we can use waitpid().

    $SIG{CHLD} = 'DEFAULT';

    if (($child = fork()) == 0)
    {

        # In Perl all file handles have FD_CLOEXEC set by default and so we
        # only need to worry about resetting signal handlers to their default
        # disposition before making the exec call.

        foreach my $sig (keys(%SIG))
        {
            $SIG{$sig} = 'DEFAULT';
        }
        exec(@cmd) or _exit($!);

    }

    # Wait a bit and them make sure that things have worked ok.

    sleep(1);
    if (not defined($child)
        or (waitpid($child, WNOHANG) == $child
            and not (WIFEXITED($CHILD_ERROR)
                     and WEXITSTATUS($CHILD_ERROR) == 0)))
    {
        $! = WEXITSTATUS($CHILD_ERROR)
            if (defined($CHILD_ERROR) && WIFEXITED($CHILD_ERROR));
        my $prog = (split(/ /, $cmd[0]))[0];
        problem_dialog('warning',
                       __x("The {name} subprocess could\n"
                               . "not start, the system gave:\n"
                               . '<b><i>{error_message}</i></b>',
                           name => Glib::Markup::escape_text($prog),
                           error_message => Glib::Markup::escape_text($!)));
    }

    # Start ignoring SIGCHLD again and reap any outstanding subprocesses.

    $SIG{CHLD} = 'IGNORE';
    while (waitpid(-1, WNOHANG) > 0) {}

    return;

}
#
##############################################################################
#
#   Routine      - ping_host
#
#   Description  - Checks to see if the specified host is available by
#                  attempting a brief connection to the relevant port.
#
#   Data         - $host        : The hostname or IP address to connect to.
#                  $port        : The port to connect to.
#                  $timeout     : The timeout, in seconds, to wait before
#                                 giving up.
#                  Return Value : True for ok, otherwise false for a
#                                 connection issue.
#
##############################################################################



sub ping_host($host, $port, $timeout)
{

    my $socket = IO::Socket::INET->new(PeerAddr => $host,
                                       PeerPort => $port,
                                       Proto    => 'tcp',
                                       Timeout  => $timeout);
    if (defined($socket))
    {
        $socket->close();
        return 1;
    }
    else
    {
        my $err = $!;
        $err = 'Unknown hostname' if ($! == EINVAL);
        problem_dialog('warning',
                       __x("Cannot connect to {host}, the reason given was:\n"
                               . '<b><i>{error_message}</i></b>',
                           host => $host,
                           error_message => Glib::Markup::escape_text($err)));
    }

    return;

}
#
##############################################################################
#
#   Routine      - load_settings
#
#   Description  - Loads in the users settings file that contains all the
#                  settings and sessions that are to be managed.
#
#   Data         - $sessions    : A reference to a scalar that is to contain a
#                                 reference to the list of session records.
#                  $settings    : A reference to a scalar that is to contain a
#                                 reference to the general settings record.
#                  Return Value : True on success, otherwise false on failure.
#
##############################################################################



sub load_settings($sessions, $settings)
{

    my @editor = ('gvim', '{file-name}');
    my @terminal = ('konsole',
                    '-p',
                    'RemoteTabTitleFormat={title}',
                    '-e',
                    '{ssh-command-args}');

    $$settings = {terminal              => \@terminal,
                  editor                => \@editor,
                  rdp_defaults          => {},
                  ssh_defaults          => {},
                  vnc_defaults          => {},
                  tigervnc_profile_path => undef,
                  screen_size           => {width  => undef,
                                            height => undef},
                  usable_desktop_size   => {width  => undef,
                                            height => undef},
                  history_size          => 20,
                  debug                 => 0};
    local $@;
    eval
    {
            my $screen = Gtk3::Gdk::Screen::get_default();
            my $workarea = Gtk3::Gdk::Monitor::get_workarea
                (Gtk3::Gdk::Display::get_primary_monitor
                 (Gtk3::Gdk::Display::get_default));
            $$settings->{screen_size}->{width} = $screen->get_width();
            $$settings->{screen_size}->{height} = $screen->get_height();
            $$settings->{usable_desktop_size}->{width} = $workarea->{width};
            $$settings->{usable_desktop_size}->{height} = $workarea->{height};
    };

    # Attempt to open the settings file, if it doesn't exist then create it.

    my $fname = settings_file_full_path(USER_SETTINGS_FILE);
    if (-e $fname and -f $fname)
    {

        # Read in and validate the YAML settings file.

        my $yaml_data;
        {
            local $@;
            my $err;
            my $ok = 1;
            eval
            {
                local $YAML::XS::ForbidDuplicateKeys = 1;
                $yaml_data = YAML::XS::LoadFile($fname);
                1;
            }
            or do
            {
                $err = $@;
                $ok = 0;
            };
            if ($ok)
            {
                my $verifier = Config::Verifier->new(\%settings_syntax_tree);
                $err = $verifier->check($yaml_data, 'settings');
            }
            if ($err)
            {
                chomp($err);
                $err =~ s/ at \S+ line \d+.$/./g;
                problem_dialog
                    ('error',
                     __x('Your preferences could not be loaded as it failed to '
                             . "parse correctly:\n"
                             . '<b><i>{error_message}</i></b>',
                         error_message => Glib::Markup::escape_text($err)));

                # We have dealt with the error so reset $! so that we don't get
                # the general failure dialog pop up as well when we exit.

                $! = 0;

                return;
            }
        }

        # Deal with the general settings.

        foreach my $key (keys(%{$$settings}))
        {
            $$settings->{$key} = $yaml_data->{settings}->{$key}
                if (exists($yaml_data->{settings}->{$key}));
        }
        my $found;
        foreach my $arg (@{$$settings->{terminal}})
        {
            if ($arg =~ m/$ssh_cmd_tokens_re/)
            {
                $found = 1;
                last;
            }
        }
        unless ($found)
        {
            problem_dialog('warning',
                           __("Your terminal entry contains no reference\n"
                              . "to `{ssh-command}' nor `{ssh-command-args}'.\n"
                              . 'Reverting to the default setting.'));
            $$settings->{terminal} = \@terminal;
        }
        $found = 0;
        foreach my $arg (@{$$settings->{editor}})
        {
            if ($arg =~ m/$file_name_token_re/)
            {
                $found = 1;
                last;
            }
        }
        unless ($found)
        {
            problem_dialog('warning',
                           __('Your editor entry contains no reference to '
                              . "`{file-name}'.\n"
                              . 'Reverting to the default setting.'));
            $$settings->{editor} = \@editor;
        }

        # Convert the read in menu entries into lists of typed session objects.

        $$sessions = yaml_data_to_objects($yaml_data->{menu});

    }
    else
    {
        my $fh;
        if (defined($fh = IO::File->new($fname, 'w')))
        {
            $fh->print($setting_header);
            $fh->close();
        }
        $$sessions = [];
    }

    if ($$settings->{debug})
    {
        logger("Settings dump:\n%s",
               Data::Dumper->Dump([$$settings], ['*settings']));
        logger("Sessions dump:\n%s",
               Data::Dumper->Dump([$$sessions], ['*sessions']));
    }

    return 1;

}
#
##############################################################################
#
#   Routine      - yaml_data_to_objects
#
#   Description  - Take YAML data representing a list of menu entries and turn
#                  this into a list of fully initialised menu objects.
#
#   Data         - yaml_data    : A reference to a list of menu items as read
#                                 in from the YAML settings file.
#                  rdp_index    : A reference to the current RDP entry index.
#                                 This is only used during recursion.
#                  defaults     : A reference to the initialised default
#                                 values record. This is only used during
#                                 recursion.
#                  Return Value : A reference to a list of menu objects.
#
##############################################################################



sub yaml_data_to_objects($yaml_data, $rdp_index = undef, $defaults = undef)
{

    my $duplicate_defaults;
    my $user = ($ENV{LOGNAME} or $ENV{USERNAME} or $ENV{USER});
    my %is_boolean = (admin           => undef,
                      bitmap_cache    => undef,
                      compositor      => undef,
                      compress        => undef,
                      draw_line       => undef,
                      home_drive      => undef,
                      ignore_certs    => undef,
                      keep_alive      => undef,
                      keyboard_grab   => undef,
                      menu_animations => undef,
                      microphone      => undef,
                      share_clipboard => undef,
                      smooth_fonts    => undef,
                      sound           => undef,
                      themes          => undef,
                      wallpaper       => undef,
                      window_drag     => undef,
                      x11_tunnel      => undef);

    # Define default constructor data values for all session classes and then
    # search for any default entries and adjust our data accordingly.

    if (not defined($defaults))
    {
        $defaults =
            {'separator' => {id        => -1,
                             text      => undef,
                             draw_line => 0},
             'menu'      => {id    => -1,
                             name  => undef,
                             items => []},
             'rdp'       => {id                 => -1,
                             name               => undef,
                             host               => undef,
                             port               => undef,
                             user               => $user,
                             domain_name        => undef,
                             window_mode        => 'maximised-no-boarders',
                             colour_depth       => 32,
                             compression_level  => undef,
                             disk_shares        => undef,
                             network            => undef,
                             tls_security_level => 1,
                             admin              => 0,
                             compositor         => 1,
                             compress           => 1,
                             home_drive         => 0,
                             ignore_certs       => 0,
                             keyboard_grab      => 1,
                             menu_animations    => 1,
                             microphone         => 0,
                             share_clipboard    => 1,
                             smooth_fonts       => 1,
                             sound              => 0,
                             themes             => 1,
                             toolbar            => 0,
                             wallpaper          => 1,
                             window_drag        => 1,
                             custom_arguments   => []},
             'vnc'       => {id      => -1,
                             name    => undef,
                             host    => undef,
                             port    => 1,
                             profile => 'default'},
             'ssh'       => {id               => -1,
                             name             => undef,
                             host             => undef,
                             port             => undef,
                             user             => $user,
                             keep_alive       => 0,
                             x11_tunnel       => 0,
                             custom_arguments => []}};

        # Look through the settings record, copying across any overridden
        # default values.

        my %defined_defaults;
        foreach my $entry (keys(%$settings))
        {
            if ($entry =~ m/^(.+)_defaults$/)
            {
                my $type = $1;
                if (exists($defined_defaults{$type}))
                {
                    $duplicate_defaults = 1;
                    next;
                }
                $defined_defaults{$type} = undef;
                my $iter = iterator($settings->{$entry});
                while (my ($key, $value) = $iter->())
                {
                    $defaults->{$type}->{$key} = exists($is_boolean{$key})
                        ? Config::Verifier->string_to_boolean($value) : $value
                        unless ($key =~ m/^host|name$/);
                }
            }
        }

        # Now update the default entries under the settings record.

        foreach my $type (qw(rdp ssh vnc))
        {
            $settings->{$type . '_defaults'} = $defaults->{$type};
        }
    }

    # Convert the YAML data into a list of objects, one class for each type of
    # menu entry.

    if (not defined($rdp_index))
    {
        my $i = 0;
        $rdp_index = \$i;
    }
    my @menu_entries;
    foreach my $entry (@$yaml_data)
    {
        my %obj;
        my $type = (keys(%$entry))[0];
        my $iter = iterator($defaults->{$type});
        while (my ($key, $value) = $iter->())
        {
            $obj{$key} = exists($entry->{$type}->{$key})
                ? $entry->{$type}->{$key} : $value;
            $obj{$key} = Config::Verifier->string_to_boolean($obj{$key})
                if (exists($is_boolean{$key}));
        }
        if ($type eq 'menu')
        {
            $obj{items} = yaml_data_to_objects($entry->{menu}->{items},
                                               $rdp_index,
                                               $defaults);
        }
        $obj{id} = $$rdp_index;
        ++ $$rdp_index;
        push(@menu_entries, bless(\%obj, $type));
    }

    if ($duplicate_defaults)
    {
        problem_dialog('warning',
                       __("Duplicate default session settings were found.\n"
                          . 'These have been ignored. Please rectify.'));
    }

    return \@menu_entries;

}
#
##############################################################################
#
#   Routine      - patch_up_syntax_table
#
#   Description  - Patch the syntax table to allow for recursive menu
#                  definitions and build up the session defaults records from
#                  the main session definitions, so as to avoid lengthy
#                  duplication.
#
#   Data         - None.
#
##############################################################################



sub patch_up_syntax_table()
{

    # Recursive menu definitions.

    foreach my $entry (@{$settings_syntax_tree{'m:menu'}})
    {
        if (exists($entry->{'m:menu'}))
        {
            $entry->{'m:menu'}->{'m:items'} = $settings_syntax_tree{'m:menu'};
            last;
        }
    }

    # Defaults duplication (may expand in the future from just RDP).

    my $search =
        sub {
            my $type = $_[0];
            foreach my $entry (@{$settings_syntax_tree{'m:menu'}})
            {
                return $entry->{"m:${type}"} if (exists($entry->{"m:${type}"}));
            }
        };
    foreach my $type ('rdp')
    {
        my %defaults;
        my $record = $search->($type);
        my $iter = iterator($search->($type));
        while (my ($key, $value) = $iter->())
        {
            $defaults{$key} = $value unless ($key =~ m/^(?:m:name|m:host)$/);
        }
        push(@{$settings_syntax_tree{'m:menu'}},
             {"m:${type}_defaults" => \%defaults});
    }

    return;

}
#
##############################################################################
#
#   Routine      - find_rdp_session_entry
#
#   Description  - Given an RDP entry id, find the corresponding session
#                  entry.
#
#   Data         - $sessions    : A reference to a list of sessions that is to
#                                 be searched recursively.
#                  id           : The entry id that is to be found.
#                  Return Value : A reference to the found entry on success,
#                                 otherwise undef on failure.
#
##############################################################################



sub find_rdp_session_entry($sessions, $id)
{

    # An id of -1 means the generic default RDP session.

    return $settings->{rdp_defaults} if ($id == -1);

    foreach my $entry (@$sessions)
    {
        if (ref($entry) eq 'menu')
        {
            my $entry = find_rdp_session_entry($entry->{items}, $id);
            return $entry if (defined($entry));
        }
        elsif ($entry->{id} == $id and ref($entry) eq 'rdp')
        {
            return $entry;
        }
    }

    return undef;

}
#
##############################################################################
#
#   Routine      - process_custom_argument_tokens
#
#   Description  - Returns the name of the user's settings file.
#
#   Data         - args         : A reference to a list of arguments that are
#                                 to have their tokens replaced with values.
#                  Return Value : A copy of the specified list with the tokens
#                                 replaced.
#
##############################################################################



sub process_custom_argument_tokens($args)
{

    my @new_args;

    my @tokens = ({re    => $desktop_width_token_re,
                   value => $settings->{screen_size}->{width}},
                  {re    => $desktop_height_token_re,
                   value => $settings->{screen_size}->{height}},
                  {re    => $desktop_usable_width_token_re,
                   value => $settings->{usable_desktop_size}->{width}},
                  {re    => $desktop_usable_height_token_re,
                   value => $settings->{usable_desktop_size}->{height}});

    foreach my $arg (@$args)
    {
        my $new_arg = $arg;
        foreach my $token (@tokens)
        {
            if ($new_arg =~ m/$token->{re}/)
            {
                $new_arg =~ s/$token->{re}/$token->{value}/g;
            }
        }
        push(@new_args, $new_arg);
    }

    return @new_args;

}
#
##############################################################################
#
#   Routine      - load_rdp_history
#
#   Description  - Returns the list of previously saved ad-hoc RDP connection
#                  details entered into the RDP connection dialog.
#
#   Data         - Return Value : A list of connection details.
#
##############################################################################



sub load_rdp_history()
{

    my ($fh,
        @list);

    defined($fh = IO::File->new(settings_file_full_path(USER_RDP_HISTORY_FILE),
                                'r'))
        or return;
    while (my $line = $fh->getline())
    {
        chomp($line);
        push(@list, $line) if ($line !~ m/^\s*#/);
    }
    $fh->close();

    return @list;

}
#
##############################################################################
#
#   Routine      - update_rdp_history
#
#   Description  - Updates the saved list of ad-hoc RDP connection details
#                  that have been entered into the RDP connection dialog or
#                  its history.
#
#   Data         - $rdp_details : Newly entered or selected details for an RDP
#                                 connection.
#
##############################################################################



sub update_rdp_history($rdp_details)
{

    my ($fh,
        %hit_map,
        @list);
    my $rdp_history_file = settings_file_full_path(USER_RDP_HISTORY_FILE);

    # If the entry is already in the list then don't bother saving anything.

    @list = load_rdp_history();
    @hit_map{@list} = undef;
    return if (exists($hit_map{$rdp_details}));

    # Ok it's changed so save it.

    if (not defined($fh = IO::File->new($rdp_history_file, 'w')))
    {
        problem_dialog
            ('warning',
             __x("Cannot save the RDP connection history to\n"
                     . "{file_name},\nthe system gave:\n"
                     . '<b><i>{error_message}</i></b>',
                 file_name => Glib::Markup::escape_text($rdp_history_file),
                 error_message => Glib::Markup::escape_text($!)));
        return;
    }

    $fh->print("# DO NOT EDIT - This file will be overwritten.\n");
    unshift(@list, $rdp_details);
    splice(@list, $settings->{history_size});
    foreach my $entry (@list)
    {
        $fh->print($entry . "\n");
    }
    $fh->close();

}
#
##############################################################################
#
#   Routine      - problem_dialog
#
#   Description  - Displays the given message in a warning or error diaglog.
#
#   Data         - $severity : A string containing `warning' or `error'.
#                  $message  : A string containing the message in markup
#                              format that is to be displayed.
#
##############################################################################



sub problem_dialog($severity, $message)
{

    my $dialog = Gtk3::MessageDialog->new_with_markup
        (undef, ['modal'], $severity, 'close', $message);
    $dialog->set_title(__('Connection Manager - ' . ufirst($severity)));
    $dialog->set_icon_name(ICON_NAME);
    $dialog->set_position('center-always');
    $dialog->run();
    $dialog->destroy();

    return;

}
#
##############################################################################
#
#   Routine      - settings_file_has_changed
#
#   Description  - Returns whether the user's settings file has changed since
#                  the last time this routine was called.
#
#   Data         - Return Value : True if the user's settings file has
#                                 changed, otherwise false if it hasn't.
#
##############################################################################



sub settings_file_has_changed()
{

    my $fname = settings_file_full_path(USER_SETTINGS_FILE);
    state $ctime = 0;

    if (-e $fname)
    {
        my $new_ctime = (stat($fname))[10];
        if ($new_ctime != $ctime)
        {
            $ctime = $new_ctime;
            return 1;
        }
    }

    return;

}
#
##############################################################################
#
#   Routine      - settings_file_full_path
#
#   Description  - Returns the the full path to the specified settings file.
#
#   Data         - $file_name   : The name of the file to look for.
#                  Return Value : The name of the user's settings file.
#
##############################################################################



sub settings_file_full_path($file_name)
{

    return File::Spec->catfile($ENV{HOME}, '.config', $file_name)
        if (exists($ENV{HOME}));
    return File::Spec->catfile($ENV{USERPROFILE}, '.config', $file_name)
        if (exists($ENV{USERPROFILE}));
    return $file_name;

}
#
##############################################################################
#
#   Routine      - vnc_path
#
#   Description  - Returns the path of the user's VNC settings directory.
#
#   Data         - Return Value : The name of the user's VNC settings
#                                 directory.
#
##############################################################################



sub vnc_path()
{

    return $settings->{tigervnc_profile_path}
        if (defined($settings->{tigervnc_profile_path}));
    return File::Spec->catdir($ENV{HOME}, '.vnc') if (exists($ENV{HOME}));
    return File::Spec->catfile($ENV{USERPROFILE}, '.vnc')
        if (exists($ENV{USERPROFILE}));
    return '.';

}
